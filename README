NAME
    Attribute::Util - A selection of general-utility attributes

SYNOPSIS
      use Attribute::Util;

      # Alias

      sub color : Alias(colour) { return 'red' }

      # Abstract

      package MyObj;
      sub new { ... }
      sub somesub: Abstract;

      package MyObj::Better;
      use base 'MyObj';
      sub somesub { return "I'm implemented!" }

      # Memoize

      sub fib :Memoize {
              my $n = shift;
              return $n if $n < 2;
              fib($n-1) + fib($n-2);
      }
  
      $|++;
      print fib($_),"\n" for 1..50;

      # SigHandler

      sub myalrm : SigHandler(ALRM, VTALRM) { ...  }
      sub mywarn : SigHandler(__WARN__) { ... }

DESCRIPTION
    This module provides four universally accessible attributes of general
    interest:

    Memoize
        This attribute makes it slightly easier (and modern) to memoize a
        function by providing an attribute, `:Memoize' that makes it
        unnecessary for you to explicitly call `Memoize::memoize()'. Options
        can be passed via the attribute per usual (see the
        `Attribute::Handlers' manpage for details, and the `Memoize' manpage
        for information on memoizing options):

          sub f :Memoize(NORMALIZER => 'main::normalize_f') {
                ...
          }

        However, since the call to `memoize()' is now done in a different
        package, it is necessary to include the package name in any function
        names passed as options to the attribute, as shown above.

    Abstract
        Declaring a subroutine to be abstract using this attribute causes a
        call to it to die with a suitable exception. Subclasses are expected
        to implement the abstract method.

        Using the attribute makes it visually distinctive that a method is
        abstract, as opposed to declaring it without any attribute or method
        body, or providing a method body that might make it look as though
        it was implemented after all.

    Alias
        If you need a variable or subroutine to be known by another name,
        use this attribute. Internally, the attribute's handler assigns
        typeglobs to each other. As such, the `Alias' attribute provides a
        layer of abstraction. If the underlying mechanism changes in a
        future version of Perl (say, one that might not have the concept of
        typeglobs anymore :), a new version of this module will take care of
        that, but your `Alias' declarations are going to stay the same.

        Note that assigning typeglobs means that you can't specify a synonym
        for one element of the glob and use the same synonym for a different
        target name in a different slot. I.e.,

          sub color :Alias(colour) { ... }
          my $farbe :Alias(colour);

        doesn't make sense, since the sub declaration aliases the whole
        `colour' glob to `color', but then the scalar declaration aliases
        the whole `colour' glob to `farbe', so the first alias is lost.

    SigHandler
        When used on a subroutine, this attribute declares that subroutine
        to be a signal handler for the signal(s) given as options for this
        attribute. It thereby frees you from the implementation details of
        defining sig handlers and keeps the handler definitions where they
        belong, namely with the handler subroutine.

BUGS
    None known so far. If you find any bugs or oddities, please do inform
    the author.

AUTHOR
    Marcel Grunauer, <marcel@codewerk.com>

COPYRIGHT
    Copyright 2001 Marcel Grunauer. All rights reserved.

    This library is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself.

SEE ALSO
    perl(1), Attribute::Handlers(3pm), Memoize(3pm).

